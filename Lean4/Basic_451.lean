--------------------------------------------------------------------------------
-- Basic_451.lean
-- 演習問題 451〜470（テンソル的法則 / reach・must の閉包演算子 / residual設計）
-- ※ import Mathlib なし
-- ※ 401〜450 は Basic_401 を import して再利用
--------------------------------------------------------------------------------

import Lean4.Basic_101
import Lean4.Basic_151
import Lean4.Basic_201
import Lean4.Basic_301
import Lean4.Basic_351
import Lean4.Basic_401

namespace TL

variable {α β γ δ ε : Type}

--------------------------------------------------------------------------------
-- 451：合成の結合律（テンソル縮約の結合性）
-- (R;S);T = R;(S;T)
--
-- ヒント：
--   funext a d; apply propext
--   constructor <;> intro h
--   h から witness を取り直す（∃ の並べ替え）
--------------------------------------------------------------------------------
theorem ex451 (R : Rel α β) (S : Rel β γ) (T : Rel γ δ) :
    relComp (relComp R S) T = relComp R (relComp S T) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 452：左単位元（id;R = R）
--
-- ヒント：
--   funext a b; apply propext; constructor <;> intro h
--   relId の witness は rfl
--------------------------------------------------------------------------------
theorem ex452 (R : Rel α β) :
    relComp (relId α) R = R := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 453：右単位元（R;id = R）
--------------------------------------------------------------------------------
theorem ex453 (R : Rel α β) :
    relComp R (relId β) = R := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 454：合成は左の和（∨）に分配する
-- (R+S);T = (R;T) + (S;T)
--
-- ヒント：
--   dsimp [relComp, relAdd]; funext a c; apply propext
--   witness を取り、cases で ∨ を分解
--------------------------------------------------------------------------------
theorem ex454 (R S : Rel α β) (T : Rel β γ) :
    relComp (relAdd R S) T = relAdd (relComp R T) (relComp S T) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 455：合成は右の和（∨）に分配する
-- R;(S+T) = (R;S) + (R;T)
--------------------------------------------------------------------------------
theorem ex455 (R : Rel α β) (S T : Rel β γ) :
    relComp R (relAdd S T) = relAdd (relComp R S) (relComp R T) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 456：transpose は 2回で元に戻る（反変×反変 = 共変）
-- (Rᵀ)ᵀ = R
--
-- ヒント：rfl で通るはず
--------------------------------------------------------------------------------
theorem ex456 (R : Rel α β) :
    relTrans (relTrans R) = R := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 457：transpose は合成の順序を逆にする
-- (R;S)ᵀ = Sᵀ ; Rᵀ
--
-- ヒント：
--   funext c a; apply propext; constructor <;> intro h
--   h の witness をそのまま使う
--------------------------------------------------------------------------------
theorem ex457 (R : Rel α β) (S : Rel β γ) :
    relTrans (relComp R S) = relComp (relTrans S) (relTrans R) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- Pred の補助：⊤ / ⊥
--------------------------------------------------------------------------------
def predTop {X : Type} : Pred X := fun _ => True
def predBot {X : Type} : Pred X := fun _ => False

--------------------------------------------------------------------------------
-- 458：reach は集合の和（∨）に分配する
-- reach R (A ∪ C) = reach R A ∪ reach R C
--
-- ヒント：
--   funext x; apply propext
--   dsimp [reach, relImg, relStar, predAdd]
--   ∃a, (A a ∨ C a) ∧ ... を ∨ に押し出す
--------------------------------------------------------------------------------
theorem ex458 (R : Rel α α) (A C : Pred α) :
    reach R (predAdd A C) = predAdd (reach R A) (reach R C) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 459：must は集合の積（∧）に分配する
-- must R (B ∩ C) = must R B ∩ must R C
--
-- ヒント：
--   funext a; apply propext
--   dsimp [must, relPreAll, relStar, predMul]
--   (A → (P ∧ Q)) ↔ (A→P) ∧ (A→Q)
--------------------------------------------------------------------------------
theorem ex459 (R : Rel α α) (B C : Pred α) :
    must R (predMul B C) = predMul (must R B) (must R C) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 460：reach は ⊥ を保つ（空集合からは何も到達しない）
-- reach R ⊥ = ⊥
--------------------------------------------------------------------------------
theorem ex460 (R : Rel α α) :
    reach R (predBot : Pred α) = (predBot : Pred α) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 461：must は ⊤ を保つ（どこに行っても True）
-- must R ⊤ = ⊤
--------------------------------------------------------------------------------
theorem ex461 (R : Rel α α) :
    must R (predTop : Pred α) = (predTop : Pred α) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 462：Closed は積（∧）で閉じる（共通部分も Closed）
-- Closed R X ∧ Closed R Y → Closed R (X ∩ Y)
--
-- ヒント：
--   dsimp [Closed, PredLe, relImg, predMul]
--   witness を取り、両方の Closed を使う
--------------------------------------------------------------------------------
theorem ex462 (R : Rel α α) (X Y : Pred α) :
    Closed R X → Closed R Y → Closed R (predMul X Y) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 463：Closed は和（∨）で閉じる（和集合も Closed）
--------------------------------------------------------------------------------
theorem ex463 (R : Rel α α) (X Y : Pred α) :
    Closed R X → Closed R Y → Closed R (predAdd X Y) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 464：reach は「A を含む最小の Closed 集合」（実用形）
-- A ⊆ X かつ Closed R X なら reach R A ⊆ X
--
-- ヒント：Basic_401 の ex411 を B := X で使うと一瞬
--------------------------------------------------------------------------------
theorem ex464 (R : Rel α α) (A X : Pred α) :
    (A ⊆ₚ X) → Closed R X → (reach R A ⊆ₚ X) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 465：must は「B の中で最大の Closed 集合」（実用形）
-- X ⊆ B かつ Closed R X なら X ⊆ must R B
--
-- ヒント：Basic_401 の ex427 をそのまま使える
--------------------------------------------------------------------------------
theorem ex465 (R : Rel α α) (B X : Pred α) :
    (X ⊆ₚ B) → Closed R X → (X ⊆ₚ must R B) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 466：安全集合から到達しても安全（counit 的コロラリ）
-- reach R (must R B) ⊆ B
--
-- ヒント：
--   ex416 : (reach R A ⊆ B) ↔ (A ⊆ must R B)
--   A := must R B を入れて、右側は refl で終わり
--------------------------------------------------------------------------------
theorem ex466 (R : Rel α α) (B : Pred α) :
    reach R (must R B) ⊆ₚ B := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 467：仕様 T を満たす head が2つあるなら、和(head1+head2) も仕様を満たす
-- attn(QK1,KV)⊆T かつ attn(QK2,KV)⊆T なら attn(QK1+QK2,KV)⊆T
--
-- ヒント：
--   ex454 で (QK1+QK2);KV を分解して cases で流す
--------------------------------------------------------------------------------
theorem ex467 (QK1 QK2 : Rel α β) (KV : Rel β γ) (T : Rel α γ) :
    (attnRel QK1 KV ⊆ T) →
    (attnRel QK2 KV ⊆ T) →
    (attnRel (relAdd QK1 QK2) KV ⊆ T) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 468：和(head1+head2) が仕様を満たすなら、それぞれの head も満たす
--
-- ヒント：
--   QK1 ⊆ QK1+QK2 は自明
--   ex436（attn の単調性）で attn QK1 KV ⊆ attn (QK1+QK2) KV
--   あとは推移
--------------------------------------------------------------------------------
theorem ex468 (QK1 QK2 : Rel α β) (KV : Rel β γ) (T : Rel α γ) :
    (attnRel (relAdd QK1 QK2) KV ⊆ T) →
      (attnRel QK1 KV ⊆ T) ∧ (attnRel QK2 KV ⊆ T) := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 469：residual で “最大の QK” を作る（仕様を必ず満たす）
-- attn( (KV ▷ T) , KV ) ⊆ T
--
-- ヒント：ex433 の (←) 方向を使うだけ
--------------------------------------------------------------------------------
theorem ex469 (KV : Rel β γ) (T : Rel α γ) :
    attnRel (rRes KV T) KV ⊆ T := by
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 470：residual の最大性（これ以上大きい QK は仕様を壊す）
-- attn(QK,KV) ⊆ T なら QK ⊆ (KV ▷ T)
--
-- ヒント：ex433 の (→) 方向
--------------------------------------------------------------------------------
theorem ex470 (QK : Rel α β) (KV : Rel β γ) (T : Rel α γ) :
    (attnRel QK KV ⊆ T) → (QK ⊆ rRes KV T) := by
  -- TODO
  sorry

end TL
