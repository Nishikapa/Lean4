--------------------------------------------------------------------------------
-- Basic_551.lean
-- 演習問題 551〜600（重み付き関係＝行列/テンソルとしての Attention：縮約・マスク・support・residual）
-- ※ import Mathlib なし
-- ※ Basic_501 を import して再利用
--------------------------------------------------------------------------------

import Lean4.Basic_501

namespace TL

variable {α β γ δ ε : Type}

--------------------------------------------------------------------------------
-- ここでの見取り図（読み物）：
--   WRel α β   : α×β 成分をもつ「重み付き関係」（行列/テンソルと思ってよい）
--   wCompList  : 中間添字 β での縮約（Σ_b QK(a,b)*KV(b,c)）
--               ※ keys : List β で有限個だけ足す（実装上の有限化）
--   wMask      : 0/1 マスクとの要素積（Hadamard 積）
--   attnNat    : score(a,b) と val(b) を縮約して a ごとのスカラーを作る（注意機構の集約）
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 補助：Rel の ⊤ / ⊥（Prop の上の関係）
--------------------------------------------------------------------------------
def relTop (α β : Type) : Rel α β := fun _ _ => True
def relBot (α β : Type) : Rel α β := fun _ _ => False

--------------------------------------------------------------------------------
-- 補助：ベクトル（β → Nat）を WRel β Unit に埋め込む
--------------------------------------------------------------------------------
def vecAsWRel (v : β → Nat) : WRel β Unit :=
  fun b _ => v b

--------------------------------------------------------------------------------
-- 補助：support（正の重みがある場所を Prop 関係として見る）
--------------------------------------------------------------------------------
def wSupp (R : WRel α β) : Rel α β :=
  fun a b => R a b > 0

--------------------------------------------------------------------------------
-- 551〜560：wCompList（縮約）の基本法則（ゼロ/空/再帰/単調性）
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 551：左ゼロ（QK=0 なら合成も 0）
--------------------------------------------------------------------------------
theorem ex551 (keys : List β) (KV : WRel β γ) :
    wCompList keys (wZero α β) KV = wZero α γ := by
  -- ヒント：funext a c; keys で帰納（[] / b::keys）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 552：右ゼロ（KV=0 なら合成も 0）
--------------------------------------------------------------------------------
theorem ex552 (keys : List β) (QK : WRel α β) :
    wCompList keys QK (wZero β γ) = wZero α γ := by
  -- ヒント：ex551 と同様に keys で帰納
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 553：空 keys（足す項が無い）
--------------------------------------------------------------------------------
theorem ex553 (QK : WRel α β) (KV : WRel β γ) :
    wCompList ([] : List β) QK KV = wZero α γ := by
  -- ヒント：wCompList の定義を dsimp
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 554：cons 展開（“先頭の項 + 残り”）
--------------------------------------------------------------------------------
theorem ex554 (b : β) (keys : List β) (QK : WRel α β) (KV : WRel β γ) :
    ∀ a c, wCompList (b :: keys) QK KV a c
          = QK a b * KV b c + wCompList keys QK KV a c := by
  -- ヒント：dsimp [wCompList] で定義展開
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 555：singleton keys（1項だけの縮約）
--------------------------------------------------------------------------------
theorem ex555 (b : β) (QK : WRel α β) (KV : WRel β γ) :
    ∀ a c, wCompList [b] QK KV a c = QK a b * KV b c := by
  -- ヒント：ex554 と ex553
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 556：append 分解（keys を2つに分けると “和” になる）
--------------------------------------------------------------------------------
theorem ex556 (keys1 keys2 : List β) (QK : WRel α β) (KV : WRel β γ) :
    ∀ a c,
      wCompList (keys1 ++ keys2) QK KV a c
        = wCompList keys1 QK KV a c + wCompList keys2 QK KV a c := by
  -- ヒント：keys1 で帰納（[] / b::keys1）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 557：縮約の結合（2段縮約の結合性）
-- keysβ で β を縮約し、その後 keysg で γ を縮約するのは、
-- 先に γ を縮約してから β を縮約するのと同じ（型が合う形で）
--------------------------------------------------------------------------------
theorem ex557 (keysβ : List β) (keysg : List γ)
    (R : WRel α β) (S : WRel β γ) (T : WRel γ δ) :
    wCompList keysg (wCompList keysβ R S) T
      = wCompList keysβ R (wCompList keysg S T) := by
  -- ヒント：funext a d; どちらも「二重和」になるので
  --         keysβ / keysg のどちらかで帰納して整理
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 558：左単調性（QK を増やすと結果も増える）
--------------------------------------------------------------------------------
theorem ex558 (keys : List β) (QK QK' : WRel α β) (KV : WRel β γ) :
    WLe QK QK' → WLe (wCompList keys QK KV) (wCompList keys QK' KV) := by
  -- ヒント：keys で帰納、各項で ≤ を使う
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 559：右単調性（KV を増やすと結果も増える）
--------------------------------------------------------------------------------
theorem ex559 (keys : List β) (QK : WRel α β) (KV KV' : WRel β γ) :
    WLe KV KV' → WLe (wCompList keys QK KV) (wCompList keys QK KV') := by
  -- ヒント：keys で帰納
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 560：両側単調性（まとめ）
--------------------------------------------------------------------------------
theorem ex560 (keys : List β) (QK QK' : WRel α β) (KV KV' : WRel β γ) :
    WLe QK QK' → WLe KV KV' →
    WLe (wCompList keys QK KV) (wCompList keys QK' KV') := by
  -- ヒント：ex558 と ex559 を合成
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 561〜570：attnNat を “縮約として” 扱う（再帰形 / 線形性 / 単調性）
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 561：attnNat は「Unit への縮約」として書ける
--------------------------------------------------------------------------------
theorem ex561 (keys : List β) (score : α → β → Nat) (val : β → Nat) :
    ∀ a : α, attnNat keys score val a = wCompList keys score (vecAsWRel val) a () := by
  -- ヒント：keys で帰納。attnNat と wCompList の再帰が一致するはず。
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 562：attnNat（空 keys）
--------------------------------------------------------------------------------
theorem ex562 (score : α → β → Nat) (val : β → Nat) :
    ∀ a : α, attnNat ([] : List β) score val a = 0 := by
  -- ヒント：dsimp [attnNat]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 563：attnNat の cons 展開
--------------------------------------------------------------------------------
theorem ex563 (b : β) (keys : List β) (score : α → β → Nat) (val : β → Nat) :
    ∀ a : α, attnNat (b :: keys) score val a
            = score a b * val b + attnNat keys score val a := by
  -- ヒント：dsimp [attnNat]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 564：score が 0 なら attention も 0
--------------------------------------------------------------------------------
theorem ex564 (keys : List β) (val : β → Nat) :
    ∀ a : α, attnNat keys (fun _ _ => 0) val a = 0 := by
  -- ヒント：keys で帰納（ex563 を使う）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 565：val が 0 なら attention も 0
--------------------------------------------------------------------------------
theorem ex565 (keys : List β) (score : α → β → Nat) :
    ∀ a : α, attnNat keys score (fun _ => 0) a = 0 := by
  -- ヒント：keys で帰納（ex563）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 566：val について線形（val1+val2）
--------------------------------------------------------------------------------
theorem ex566 (keys : List β) (score : α → β → Nat) (val1 val2 : β → Nat) :
    ∀ a : α,
      attnNat keys score (fun b => val1 b + val2 b) a
        = attnNat keys score val1 a + attnNat keys score val2 a := by
  -- ヒント：keys で帰納、Nat の分配則
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 567：score について線形（score1+score2）
--------------------------------------------------------------------------------
theorem ex567 (keys : List β) (score1 score2 : α → β → Nat) (val : β → Nat) :
    ∀ a : α,
      attnNat keys (fun a b => score1 a b + score2 a b) val a
        = attnNat keys score1 val a + attnNat keys score2 val a := by
  -- ヒント：keys で帰納
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 568：score に単調（pointwise ≤）
--------------------------------------------------------------------------------
theorem ex568 (keys : List β) (score score' : α → β → Nat) (val : β → Nat) :
    (∀ a b, score a b ≤ score' a b) →
    (∀ a : α, attnNat keys score val a ≤ attnNat keys score' val a) := by
  -- ヒント：keys で帰納、Nat の単調性
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 569：val に単調（pointwise ≤）
--------------------------------------------------------------------------------
theorem ex569 (keys : List β) (score : α → β → Nat) (val val' : β → Nat) :
    (∀ b, val b ≤ val' b) →
    (∀ a : α, attnNat keys score val a ≤ attnNat keys score val' a) := by
  -- ヒント：keys で帰納
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 570：keys の append（足し算に分解）
--------------------------------------------------------------------------------
theorem ex570 (keys1 keys2 : List β) (score : α → β → Nat) (val : β → Nat) :
    ∀ a : α,
      attnNat (keys1 ++ keys2) score val a
        = attnNat keys1 score val a + attnNat keys2 score val a := by
  -- ヒント：keys1 で帰納（ex563）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 571〜580：マスク（0/1 要素積）の法則（⊤/⊥/冪等/単調性/縮約との相性）
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 571：⊤ マスクは 1（全部通す）
--------------------------------------------------------------------------------
theorem ex571 :
    ∀ a b, maskW (relTop α β) a b = 1 := by
  -- ヒント：by classical; simp [maskW, relTop]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 572：⊥ マスクは 0（全部落とす）
--------------------------------------------------------------------------------
theorem ex572 :
    ∀ a b, maskW (relBot α β) a b = 0 := by
  -- ヒント：by classical; simp [maskW, relBot]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 573：wMask R ⊤ = R
--------------------------------------------------------------------------------
theorem ex573 (R : WRel α β) :
    wMask R (relTop α β) = R := by
  -- ヒント：funext; by classical; simp [wMask, maskW, relTop]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 574：wMask R ⊥ = 0
--------------------------------------------------------------------------------
theorem ex574 (R : WRel α β) :
    wMask R (relBot α β) = wZero α β := by
  -- ヒント：funext; by classical; simp [wMask, maskW, relBot, wZero]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 575：マスクは冪等（同じマスクを2回かけても同じ）
--------------------------------------------------------------------------------
theorem ex575 (R : WRel α β) (M : Rel α β) :
    wMask (wMask R M) M = wMask R M := by
  -- ヒント：funext; by classical; simp [wMask, maskW]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 576：マスクの合成（2枚かけるのは ∧ を1枚かけるのと同じ）
--------------------------------------------------------------------------------
theorem ex576 (R : WRel α β) (M N : Rel α β) :
    wMask (wMask R M) N = wMask R (relMul M N) := by
  -- ヒント：funext; by classical; simp [wMask, maskW, relMul]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 577：マスクすると値は増えない（≤）
--------------------------------------------------------------------------------
theorem ex577 (R : WRel α β) (M : Rel α β) :
    WLe (wMask R M) R := by
  -- ヒント：by classical; intro a b; simp [wMask, maskW]; cases (M a b)
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 578：マスクは “弱める” と単調（M ⊆ N なら mask(M) ≤ mask(N)）
--------------------------------------------------------------------------------
theorem ex578 (R : WRel α β) (M N : Rel α β) :
    (M ⊆ N) → WLe (wMask R M) (wMask R N) := by
  -- ヒント：by classical; intro hMN a b; by_cases hM : M a b
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 579：左側をマスクすると縮約は減る（≤）
--------------------------------------------------------------------------------
theorem ex579 (keys : List β) (QK : WRel α β) (KV : WRel β γ) (M : Rel α β) :
    WLe (wCompList keys (wMask QK M) KV) (wCompList keys QK KV) := by
  -- ヒント：ex577 と ex558 を使う（単調性で押す）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 580：右側をマスクすると縮約は減る（≤）
--------------------------------------------------------------------------------
theorem ex580 (keys : List β) (QK : WRel α β) (KV : WRel β γ) (N : Rel β γ) :
    WLe (wCompList keys QK (wMask KV N)) (wCompList keys QK KV) := by
  -- ヒント：ex577 と ex559
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 581〜590：support（>0）で “論理関係” に落として見る（attention をテンソル論理へ接続）
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 581：support(0) = ⊥
--------------------------------------------------------------------------------
theorem ex581 :
    wSupp (wZero α β) = relBot α β := by
  -- ヒント：funext; apply propext; dsimp [wSupp, wZero, relBot]
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 582：support(maskW M) = M
--------------------------------------------------------------------------------
theorem ex582 (M : Rel α β) :
    wSupp (maskW M) = M := by
  -- ヒント：funext; apply propext; by classical; by_cases h : M a b
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 583：support(wMask R M) = support(R) ∧ M
--------------------------------------------------------------------------------
theorem ex583 (R : WRel α β) (M : Rel α β) :
    wSupp (wMask R M) = relMul (wSupp R) M := by
  -- ヒント：funext; apply propext; by classical; by_cases h : M a b
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 584：WLe なら support の包含が成り立つ
--------------------------------------------------------------------------------
theorem ex584 (R S : WRel α β) :
    WLe R S → (wSupp R ⊆ wSupp S) := by
  -- ヒント：intro h a b hpos; have := h a b; exact lt_of_lt_of_le hpos this
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 585：support(wCompList ...) は relComp(support QK)(support KV) に含まれる
--------------------------------------------------------------------------------
theorem ex585 (keys : List β) (QK : WRel α β) (KV : WRel β γ) :
    wSupp (wCompList keys QK KV) ⊆ relComp (wSupp QK) (wSupp KV) := by
  -- ヒント：keys で帰納。
  --   ・[] は矛盾（0>0）
  --   ・b::keys は
  --       (QK a b * KV b c + rest) > 0 から
  --       (QK a b * KV b c) > 0 もしくは rest > 0 を取り出す
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 586：support から “keys の中に witness がいる” を取り出す（→ 方向）
--------------------------------------------------------------------------------
theorem ex586 (keys : List β) (QK : WRel α β) (KV : WRel β γ) :
    ∀ a c,
      wSupp (wCompList keys QK KV) a c →
        ∃ b, b ∈ keys ∧ wSupp QK a b ∧ wSupp KV b c := by
  -- ヒント：keys で帰納。b::keys の場合、head 項で決まるか tail に流すか。
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 587：witness が keys にいれば support が立つ（← 方向）
--------------------------------------------------------------------------------
theorem ex587 (keys : List β) (QK : WRel α β) (KV : WRel β γ) :
    ∀ a c,
      (∃ b, b ∈ keys ∧ wSupp QK a b ∧ wSupp KV b c) →
        wSupp (wCompList keys QK KV) a c := by
  -- ヒント：keys で帰納。mem_cons を使って cases。
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 588：まとめ：support(wCompList) の “存在” 表現
--------------------------------------------------------------------------------
theorem ex588 (keys : List β) (QK : WRel α β) (KV : WRel β γ) :
    ∀ a c,
      wSupp (wCompList keys QK KV) a c
        ↔ ∃ b, b ∈ keys ∧ wSupp QK a b ∧ wSupp KV b c := by
  -- ヒント：ex586 と ex587
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 589：wCompList の support は boolean attention（attnRel）に含まれる
--------------------------------------------------------------------------------
theorem ex589 (keys : List β) (QK : WRel α β) (KV : WRel β γ) :
    wSupp (wCompList keys QK KV) ⊆ attnRel (wSupp QK) (wSupp KV) := by
  -- ヒント：attnRel = relComp。ex585 を使うだけ。
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 590：wMask すると support も ∧ で減る（support レベルの再掲）
--------------------------------------------------------------------------------
theorem ex590 (R : WRel α β) (M : Rel α β) :
    wSupp (wMask R M) ⊆ wSupp R := by
  -- ヒント：ex583 で右射影
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 591〜600：residual（rRes）で “安全な head” を設計する（support を介して）
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 補助：KV と仕様 T から “安全な QK の条件” を作る
-- safeRel KV T a b  :=  ∀ c, (KV b c > 0) → T a c
--------------------------------------------------------------------------------
def safeRel (KV : WRel β γ) (T : Rel α γ) : Rel α β :=
  rRes (wSupp KV) T

--------------------------------------------------------------------------------
-- 591：residual の正しさ（boolean）：attnRel (KV▷T) KV ⊆ T
--------------------------------------------------------------------------------
theorem ex591 (KV : WRel β γ) (T : Rel α γ) :
    attnRel (safeRel (α:=α) KV T) (wSupp KV) ⊆ T := by
  -- ヒント：ex433 を (QK:=safeRel KV T), (KV:=wSupp KV) に適用して、
  --         右側は「X ⊆ X」で reflexive。
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 592：residual の最大性（boolean）：attnRel QK KV ⊆ T → QK ⊆ (KV▷T)
--------------------------------------------------------------------------------
theorem ex592 (QKrel : Rel α β) (KV : WRel β γ) (T : Rel α γ) :
    (attnRel QKrel (wSupp KV) ⊆ T) → (QKrel ⊆ safeRel (α:=α) KV T) := by
  -- ヒント：ex433 の (→) 方向
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 593：wCompList の support は boolean attention に含まれる（再掲：接続の要）
--------------------------------------------------------------------------------
theorem ex593 (keys : List β) (QK : WRel α β) (KV : WRel β γ) :
    wSupp (wCompList keys QK KV) ⊆ attnRel (wSupp QK) (wSupp KV) := by
  -- ヒント：ex589
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 594：安全条件（support(QK) ⊆ KV▷T）なら、support(wCompList) ⊆ T
--------------------------------------------------------------------------------
theorem ex594 (keys : List β) (QK : WRel α β) (KV : WRel β γ) (T : Rel α γ) :
    (wSupp QK ⊆ safeRel (α:=α) KV T) → (wSupp (wCompList keys QK KV) ⊆ T) := by
  -- ヒント：ex593 で boolean attention に押し上げ、ex591 で T に落とす（推移）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 595：マスクした QK は “必ず” safeRel を満たす（support で見れば自明）
--------------------------------------------------------------------------------
theorem ex595 (QK : WRel α β) (KV : WRel β γ) (T : Rel α γ) :
    wSupp (wMask QK (safeRel (α:=α) KV T)) ⊆ safeRel (α:=α) KV T := by
  -- ヒント：ex583（support(wMask)=support∧mask）で右射影
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 596：設計：QK を safeRel でマスクすれば、縮約の support は必ず T に入る
--------------------------------------------------------------------------------
theorem ex596 (keys : List β) (QK : WRel α β) (KV : WRel β γ) (T : Rel α γ) :
    wSupp (wCompList keys (wMask QK (safeRel (α:=α) KV T)) KV) ⊆ T := by
  -- ヒント：ex594 に、ex595 を入れる
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 597：すでに安全ならマスクしても変わらない（wSupp を仮定にする版）
--------------------------------------------------------------------------------
theorem ex597 (QK : WRel α β) (KV : WRel β γ) (T : Rel α γ) :
    (wSupp QK ⊆ safeRel (α:=α) KV T) →
      wMask QK (safeRel (α:=α) KV T) = QK := by
  -- ヒント：support(QK) で mask が True になることを使って funext で示す
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 598：safeRel は仕様 T に単調（T ⊆ T' なら safeRel KV T ⊆ safeRel KV T'）
--------------------------------------------------------------------------------
theorem ex598 (KV : WRel β γ) (T T' : Rel α γ) :
    (T ⊆ T') → (safeRel (α:=α) KV T ⊆ safeRel (α:=α) KV T') := by
  -- ヒント：safeRel は rRes (wSupp KV) T。ex483（rRes の右単調）を使う。
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 599：safeRel は KV（support）に反単調（KV が増えるほど safeRel は厳しくなる）
--------------------------------------------------------------------------------
theorem ex599 (KV KV' : WRel β γ) (T : Rel α γ) :
    (wSupp KV ⊆ wSupp KV') →
      (safeRel (α:=α) KV' T ⊆ safeRel (α:=α) KV T) := by
  -- ヒント：ex484（rRes の左反単調）
  -- TODO
  sorry

--------------------------------------------------------------------------------
-- 600：keys 付きの安全条件（必要十分に近い形）
-- 「keys に現れる b についてだけ」QK が安全なら、wCompList の support は T に入る
--------------------------------------------------------------------------------
theorem ex600 (keys : List β) (QK : WRel α β) (KV : WRel β γ) (T : Rel α γ) :
    (∀ a b, b ∈ keys → wSupp QK a b → safeRel (α:=α) KV T a b) →
      (wSupp (wCompList keys QK KV) ⊆ T) := by
  -- ヒント：ex588（存在表現）で witness b を取り、仮定で T を出す
  -- TODO
  sorry

end TL
