
-- ==========================================
-- 1. 全射 (Surjective) の定義
-- ==========================================

-- 集合 X から Y への写像 f があるとします。
-- 「f が全射である」とは、「任意の Y の要素 y に対して、
--  f x = y となるような X の要素 x が（少なくとも一つ）存在する」ことを言います。
def Surjective {X Y : Type} (f : X → Y) : Prop :=
  ∀ y : Y, ∃ x : X, f x = y

-- ==========================================
-- 2. 具体例: 恒等写像 (id) の全射性
-- ==========================================

-- 例として、自然数 n をそのまま n に移す写像 (n ↦ n) を考えます。
-- これが全射であることを証明します。
example : Surjective (fun n : Nat => n) := by
  -- 現在のゴールは Surjective (fun n => n) です。
  -- dsimp [Surjective] により、Surjective の定義を展開します。
  -- これにより、ゴールは論理式 ∀ (y : Nat), ∃ (x : Nat), x = y に書き換わります。
  dsimp [Surjective]

  -- 現在のゴールが ∀ (y : Nat), ∃ x, x = y なので、
  -- intro y により、先頭の全称量化子 ∀ (y : Nat) を取り除きます。
  -- これにより、任意の自然数 y がローカルコンテキスト（前提）に導入され、
  -- ゴールは「その導入された y について ∃ x, x = y を示すこと」に変化します。
  intro y

  -- 現在のゴールは ∃ x, x = y です。
  -- これは「条件を満たす x が存在すること」を示せと言っています。
  -- exists y により、存在記号 ∃ x の x として具体的な値 y を提示（代入）します。
  -- これにより、ゴールは x に y を代入した結果である y = y の証明に変化します。
  -- (y = y は反射律により自動的に証明完了となります)
  exists y

-- ==========================================
-- 3. 選択公理を使った逆写像の構成
-- ==========================================

-- ここで X と Y を任意の「型（集合）」とします。
variable {X Y : Type}

-- 以下の関数 inverse は「計算不可能 (noncomputable)」です。
-- なぜなら、具体的な計算手順ではなく「選択公理」という魔法を使って値を決めるからです。
--
-- 【関数の仕様】
--   入力 1: 写像 f : X → Y
--   入力 2: f が全射であるという事実 (hf)
--   戻り値: Y から X への写像 (逆写像)
noncomputable def inverse (f : X → Y) (hf : Surjective f) : Y → X := by

  -- 仮定 hf の型は Surjective f です。
  -- dsimp [Surjective] at hf により、hf の定義を展開します。
  -- これにより、hf の型は論理式 ∀ (y : Y), ∃ (x : X), f x = y に書き換わります。
  dsimp [Surjective] at hf

  -- 現在のゴールは Y → X (関数型) です。
  -- 関数を構成するため、intro y により入力となる Y の要素 y をローカルコンテキストに導入します。
  -- これにより、ゴールは「その y に対して X の要素を一つ返すこと」になります。
  intro y

  -- 【数学的ステップ 1: 解の存在確認】
  -- まず、「f x = y を満たす x の集合は空集合ではない（解の候補が存在する）」ことを確認します。
  -- { x // f x = y } は「条件を満たす x 全体」という部分集合のような型（Subtype）です。
  -- Nonempty { ... } は、その型を持つ値が存在するという命題です。
  have : Nonempty { x // f x = y } := by
    -- 仮定 hf は ∀ (y : Y), ∃ (x : X), f x = y という形をしています。
    -- これに現在の y を適用する(hf y)と、∃ (x : X), f x = y という存在命題が得られます。
    -- let ⟨x, hx⟩ := ... により、この存在命題を分解（除去）し、
    -- 「具体的な値 x」と「その条件を満たす証拠 hx : f x = y」をローカルコンテキストに取り出します。
    let ⟨x, hx⟩ := hf y

    -- 現在のゴールは Nonempty { x // f x = y } です。
    -- これを証明するために、Nonempty.intro コンストラクタを使います。
    -- 引数として { x // f x = y } 型のインスタンスが必要です。
    -- ⟨x, hx⟩ は Subtype.mk x hx の略記で、「値 x」と「条件 hx」をペアにして部分型のインスタンスを作ります。
    -- 外側の ⟨ ... ⟩ は Nonempty 型へのラップを行い、内側の ⟨ ... ⟩ は部分型の構築を行っています。
    -- exact ⟨⟨x, hx⟩⟩
    exact ⟨Subtype.mk x hx⟩

  -- 【数学的ステップ 2: 解の選択】
  -- ここで「選択公理 (Classical.choice)」を使います。
  -- Classical.choice の型は Nonempty α → α です。
  -- 直前のステップで示した this : Nonempty { x // f x = y } を渡すことで、
  -- 選択公理により、中身の要素（Subtype）を一つ選び出し、x_subtype と定義します。
  --
  -- 【重要】
  -- x_subtype は「条件を満たす要素の集合」ではありません。
  -- 選択公理によって、その集合の中から選び出された「たった一つの具体的な要素（インスタンス）」です。
  -- 候補が複数あったとしても、choice はその中からどれか一つを確定させて返します。
  have x_subtype := Classical.choice this

  -- x_subtype の実体は、Subtype という構造体です。
  -- Subtype は { val := 値, property := 証明 } という2つのフィールドを持っています。
  -- 先ほど ⟨x, hx⟩ で作ったペアのうち、左側の「値 (x)」を取り出す操作が .val です。
  -- (右側の「証明 (hx)」を取り出したい場合は .property を使います)
  exact x_subtype.val
